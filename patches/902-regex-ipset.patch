diff --git a/src/config.h b/src/config.h
index 6790062..740e513 100644
--- a/src/config.h
+++ b/src/config.h
@@ -139,6 +139,10 @@ HAVE_REGEX
    Define this if you want to link against lib pcre to get regex
    support in "address=" matches

+HAVE_REGEX_IPSET
+   Define this if you want to link against lib pcre to get regex
+   support in "ipset=" matches
+
 NO_ID
    Don't report *.bind CHAOS info to clients, forward such requests upstream instead.
 NO_TFTP
@@ -197,6 +201,7 @@ RESOLVFILE
 /* #define HAVE_CRYPTOHASH */
 /* #define HAVE_DNSSEC */
 /* #define HAVE_REGEX */
+/* #define HAVE_REGEX_IPSET */


 /* Default locations for important system files. */
@@ -390,7 +395,12 @@ static char *compile_opts =
 #ifndef HAVE_REGEX
 "no-"
 #endif
-"regex "
+"regex"
+#if defined(HAVE_IPSET) && defined(HAVE_REGEX) && defined(HAVE_REGEX_IPSET)
+"(+ipset) "
+#else
+" "
+#endif
 #if defined(HAVE_LIBIDN2)
 "IDN2 "
 #else
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index e308399..c793e8b 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -570,10 +570,24 @@ struct server {
 #endif
 };

+#ifdef HAVE_REGEX
+#ifdef HAVE_REGEX_IPSET
+	#define IPSET_IS_DOMAIN 0x01
+	#define IPSET_IS_REGEX 0x02
+#endif
+#endif
+
 struct ipsets {
   char **sets;
   char *domain;
   struct ipsets *next;
+#ifdef HAVE_REGEX
+#ifdef HAVE_REGEX_IPSET
+  pcre *regex;
+  pcre_extra *pextra;
+  unsigned char domain_type;
+#endif
+#endif
 };

 struct irec {
diff --git a/src/forward.c b/src/forward.c
index a60ad5b..8e7ba7c 100644
--- a/src/forward.c
+++ b/src/forward.c
@@ -701,6 +701,21 @@ static size_t process_reply(struct dns_header *header, time_t now, struct server
       unsigned int matchlen = 0;
       for (ipset_pos = daemon->ipsets; ipset_pos; ipset_pos = ipset_pos->next)
 	{
+#ifdef HAVE_REGEX
+#ifdef HAVE_REGEX_IPSET
+	  if (ipset_pos->domain_type & IPSET_IS_REGEX){
+		  int captcount = 0;
+		  if (pcre_fullinfo(ipset_pos->regex, ipset_pos->pextra, PCRE_INFO_CAPTURECOUNT, &captcount) == 0)
+		  {
+			  /* C99 dyn-array, or alloca must be used */
+			  int ovect[(captcount + 1) * 3];
+			  if (pcre_exec(ipset_pos->regex, ipset_pos->pextra, daemon->namebuff, namelen, 0, 0, ovect, (captcount + 1) * 3) > 0){
+				  sets = ipset_pos->sets;
+			  }
+		  }
+	  }else{
+#endif
+#endif
 	  unsigned int domainlen = strlen(ipset_pos->domain);
 	  char *matchstart = daemon->namebuff + namelen - domainlen;
 	  if (namelen >= domainlen && hostname_isequal(matchstart, ipset_pos->domain) &&
@@ -710,6 +725,11 @@ static size_t process_reply(struct dns_header *header, time_t now, struct server
 	      matchlen = domainlen;
 	      sets = ipset_pos->sets;
 	    }
+#ifdef HAVE_REGEX
+#ifdef HAVE_REGEX_IPSET
+	  }
+#endif
+#endif
 	}
     }
 #endif
diff --git a/src/option.c b/src/option.c
index a286ccf..9774df8 100644
--- a/src/option.c
+++ b/src/option.c
@@ -2717,6 +2717,30 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
 	     while ((end = split_chr(arg, '/')))
 	       {
 		 char *domain = NULL;
+		 char *real_end = arg + strlen(arg);
+		 if (*arg == ':' && *(real_end - 1) == ':'){
+#ifdef HAVE_REGEX
+#ifdef HAVE_REGEX_IPSET
+			 const char *error;
+			 int erroff;
+			 char *regex = NULL;
+			 *(real_end - 1) = '\0';
+			 regex = arg + 1;
+
+			 ipsets->next = opt_malloc(sizeof(struct ipsets));
+			 ipsets = ipsets->next;
+			 memset(ipsets, 0, sizeof(struct ipsets));
+			 ipsets->regex = pcre_compile(regex, 0, &error, &erroff, NULL);
+
+			 if (!ipsets->regex)
+				 ret_err(error);
+			 ipsets->pextra = pcre_study(ipsets->regex, 0, &error);
+			 ipsets->domain_type = IPSET_IS_REGEX;
+#endif
+#else
+			 ret_err("Using a regex while server was configured without regex support!");
+#endif
+		 }else{
 		 /* elide leading dots - they are implied in the search algorithm */
 		 while (*arg == '.')
 		   arg++;
@@ -2729,6 +2753,12 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
 		 ipsets = ipsets->next;
 		 memset(ipsets, 0, sizeof(struct ipsets));
 		 ipsets->domain = domain;
+#ifdef HAVE_REGEX
+#ifdef HAVE_REGEX_IPSET
+		 ipsets->domain_type = IPSET_IS_DOMAIN;
+#endif
+#endif
+		 }
 		 arg = end;
 	       }
 	   }
@@ -2737,6 +2767,11 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
 	     ipsets->next = opt_malloc(sizeof(struct ipsets));
 	     ipsets = ipsets->next;
 	     memset(ipsets, 0, sizeof(struct ipsets));
+#ifdef HAVE_REGEX
+#ifdef HAVE_REGEX_IPSET
+	     ipsets->domain_type = IPSET_IS_DOMAIN;
+#endif
+#endif
 	     ipsets->domain = "";
 	   }

